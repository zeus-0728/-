hello
数据结构学习

1：自定义线性表（顺序存储结构）
#define LIST_INIT_SIZE 100
#define LIST_INCREMENT 10

typedef int ElemType;

typedef struct SqList
{
ElemType *elem;
int length;
int list_size;
}SqList, *Ptr;
typedef Ptr sqlListpPtr;

2:初始化-创建线性表
Status :List_init(SqListPtr L)
{
status s= success;
L->List_size=LIST_INIT_SIZE;
L->length =0;
L->elem=(Elem Type *)malloc(sizeof(Elem type)*L->list_size);
if(L->elem == NULL)
s=fatal;
return s;
}

3:线性表查找（按位置查找值）
Status List_Retrival(SqListPtr L, int pos, ElemType *elem)
{
Status s = range_error;
if(L){
if((pos-1) >= 0 && (pos-1) < L->length){
*elem = L->elem[pos-1];
s = success;
}
}
else
s = fatal;
return s;
}

线性表查找（按值查找位置）
Status List_Locate(SqlistPtr L, ElemType elem, int *pos)
{
Status s = range_error;
if(L){
for(int i = 0;i < L->length; ++i){
if(l->elem[i]==elem){
*pos = i+1;
s = success;
break;
}
}
}
else s= fatal;
return s;
}

4:线性表的插入
Status List_Insert(SqlistPtr L,int pos, ElemType elem)
{
Status s =range_error;
if((pos-1) >= 0 && (pos-1) <= L->length){
if(L && L->length < L->list_size){
for(int i = L->length-1; i >= pos-1;--i){
L->elem[i+1] =L->elem[i];
}
L->elem[pos-1]= elem;
L->length++;
s = success;
}
}
else s fail;
return s;
}

5：线性表的删除
Status List_delete(SqlistPtr L,int pos)
{
Status s = range_error;
if((pos)-1 >= 0 && (pos-1) < l->length){
if(L && L->length > 0){
for(int i = pos; i < L-> length; ++i){
L->elem[i-1]=L->elem[i];
s= success;
}
}
}
else s = fall;
Return s;
}

线性表的链式存储（单链表）
1：定义两个结点 并将其串成单链表
Typedef struct Node
{
ElemType elem;
Struct Node *next;
}Node,*Ptr;
Typedef Ptr *SqlistPtr;
Node n1,n2;
Ptr p=&n1;
n1.next=&n2;
Ptr L =p;
N2.next=NULL;

2:单链表的位置查找
Status List_Retrieve(SqlistPtr L, int pos, ElemType *elem)
{
Status s = range_error;
Ptr p =(*L)->next;
int i = 1;
while(p && I < pos){
{
i++;
p=p->next;
}
if(p && I==pos)
{
*elem = p->data;
s= success;
}
}
return s;
}

3: 单链表的按值查找
Status List_Locate(SqlistPtr L, ElemType elem,int *pos)
{
Status s = range_error;
Ptr p =(*L)->next;
int i = 1;
while(p != NULL){
if(p->elem ==elem)break;
i++;
p=p->next;
}
if(p){
*pos = I;
S = success;
}
return s;
}

4:单链表的插入操作
Status LIst_Insert(SqlistPtr L, int pos ,ElemTYpe elem)
{
Status status;
Ptr p,s;
Status = List_Retrival(L, pos-1,&p);
if( status == success){
s=(LinkedPtr)malloc(sizeof(Node));
if(s){
S->elem = elem;
S->next = p->next;
p->next =s;
status = success;}
Else status = fatal;
}
Else status = range_error;
Return status;
}

5:单链表的删除
Status List_delete(SqlistPtr L, int pos)
{
Status status=fail;
Ptr s,p;
Status = List_Retrival(L,pos -1,&p);
if(status== success)
{
s=p->next;
P->next= s->next;
free(s);
s= NULL;
Status = success;
}
Return status;
}

6:建立单链表(创建一个空的单链表，一次建立各元素结点，并逐个插入链表)
Status List_create(SqlistPtr L, elemtype data[], int len){
Status s;
Ptr p;
s = List_init(L);
if(s == success){
for(int i = len-1;i>=0;--i){
p=(Ptr)malloc(sizeof(Node));
if(p){
p->elem = data[i];
p->next=(*L)->next;
(*L)->next = p;
}
else{s=fail;break;}
}
}
return s;
}

7:单链表的变形
循环单链表（最后一个结点的直接后继是空还是头结点）
带尾指针的循环单链表（
1：两个循环单链表的合并
p=La->next; //保存La的头结点指针
La->next= Lb->next->next //头尾连接
free(Lb->next); //释放第二个表的头结点
Lb->next=p; //组成循环链表
2：最后一个元素后||第一个元素加新元素
）
双向链表（elem前后各有一个指针 来这样进行连接）
（双向链表的插入操作
S->next = p->next;
p->next=s;
S->next->prior =s;
S->prior =p;
双向链表的删除操作
P->next=p->next->next;
P->next->prior = p;）
静态链表（数据元素的存储空间像顺序表一样是事先静态分配的 数据元素之间的关系是像链表一样显示的）
8：线性表的合并
Status List_Union(ListPtr La,ListPtr Lb)
{
Elem Type elem;
Status status;
int i,j,len = List_Size(Lb);
for(i=0;i<len;i++)
{
LIst_Retrieve(Lb,i,&elem);
status = List_Locate(La,elem,&j);
if(status!=success)
{
status = List_insert(La,1,elem);
if(status!=success)
break;
}
}
return status;
}

9：顺序表实现合并
Status List_Union(ListPtr ListPtr Lb)
{
Status status = success;
for(int i=1;i<=Lb->length;i++)
{
for(int j=1;j<=La->length;j++)
if(Lb->elem[i]==La->elem[j])break;
if(La->length<MAXSIZE)
{
if(j>La->length)
{
La->length++;
La->elem[length] = Lb->elem[i];
}
}
else{status=fail;break;}
}
return status;
}

10：有序表的合并
Status List_Merge(SqListPtr La,SqListPtr Lb,SqlistPtr Lc)
{
ElemType elem1,elem2;status=List_init(Lc);
int i=1,j=1,k=1;
int n=List_siza(La),m=List_init(Lb);
while(i<=n&&j<=m)
{
List_Retrieve(La,i,&elem1);
List_Retrieve(Lb,j,&elem2);
if(elem1<elem2){status = List_Insert(Lc,k,elem1);i=i+1;}
else{status = List_Insert(Lc,k,elem2);j=j+1;}
k=k+1;
}
while(i<=n)
{
List_Retrieve(La,i,&elem1);
status = List_Insert(Lc,k,elem1);
i=i+1;
k=k+1;
}
while (j<=m)
{
List_Retrieve(Lb,j,&elem2);
status = List_Insert(Lc,k,elem2);
j=j+1;
k=k+1;
}
return status;
}

11：归并两个有序表|链式存储(破坏的方法)
void merge_linklist(ListPtr *la,ListPtr *lb,ListPtr *lc)
{
LIstPtr pa,pb,pc,tp;
pa=(*la)->next;
pb=(*lb)->next;
pc=*la;
while(!pa&&!pb)
{
if(pa->datadata)
{
pc->next=pa;pc=pa;pa=pa->next;
}
else if(pa->data>pb->data)
{
pc->next=pb;pc=pb;pb=pb->next;
}
else{
pc->next=pa;
pc=pa;
pa=pa->next;
tp=pb;
pb=pb->next;
free(tp);
tp=NULL;
}
pc->next=(pa:pb);
ferr(lb);
lc=la;
}
}mer-linklist
